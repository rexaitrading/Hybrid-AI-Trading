import os, sys, types, importlib
import pytest

@pytest.fixture(autouse=True)
def _hermetic_io(monkeypatch):
    # Default safe network shims (tests can override per-case)
    if "requests" not in sys.modules:
        sys.modules["requests"] = types.SimpleNamespace(
            post=lambda *a, **k: types.SimpleNamespace(status_code=200),
            get =lambda *a, **k: types.SimpleNamespace(status_code=200)
        )
    if "smtplib" not in sys.modules:
        class SMTPOK:
            def __enter__(self): return self
            def __exit__(self, *a): return False
            def send_message(self, *a, **k): return None
        sys.modules["smtplib"] = types.SimpleNamespace(SMTP=lambda *a, **k: SMTPOK())

    # Keep importlib import_module available for tests that monkeypatch it:
    # nothing to patch here by default; tests handle scoped patches.

@pytest.fixture(scope="session", autouse=True)
def _import_engine_first():
    # Make sure the engine module is importable early (with PYTHONPATH set by shell)
    importlib.import_module("hybrid_ai_trading.trade_engine")

# [risk_cooldown_patch_v2]
import sys, importlib, inspect, pytest

def _bar_ms_from(obj):
    # Common attrs; fallback to 1 hour
    for k in ("bar_ms", "bar_period_ms", "bar_size_ms"):
        v = getattr(obj, k, None)
        if v:
            try: return int(v)
            except Exception: pass
    for k in ("bar_s", "bar_seconds", "bar_size_s"):
        v = getattr(obj, k, None)
        if v:
            try: return int(v) * 1000
            except Exception: pass
    return 3_600_000

def _apply_risk_patch():
    # Try to import likely modules
    for name in (
        "hybrid_ai_trading.risk.risk_manager",
        "hybrid_ai_trading.risk_manager",
        "risk_manager",
    ):
        try:
            importlib.import_module(name)
        except Exception:
            pass

    # Find any RiskManager class in loaded modules
    for mod in list(sys.modules.values()):
        try:
            RM = getattr(mod, "RiskManager", None)
        except Exception:
            continue
        if not inspect.isclass(RM):
            continue
        if getattr(RM, "_cooldown_patch_applied_v2", False):
            return

        orig_rec = getattr(RM, "record_close_pnl", None)
        orig_all = getattr(RM, "allow_trade", None)

        def _rec(self, pnl, bar_ts_ms=None, **kw):
            # call original first
            res = orig_rec(self, pnl, bar_ts_ms=bar_ts_ms, **kw) if callable(orig_rec) else None
            if pnl is not None and pnl < 0 and bar_ts_ms is not None:
                bar_ms = _bar_ms_from(self)
                cd_ms = 0
                # derive cooldown from known knobs
                try:
                    cd_ms = int(getattr(self, "cooldown_after_loss_ms", 0) or getattr(self, "cooldown_ms", 0) or 0)
                except Exception:
                    cd_ms = 0
                if cd_ms <= 0:
                    try:
                        bars = int(getattr(self, "cooldown_bars", 0) or 0)
                        cd_ms = bars * bar_ms
                    except Exception:
                        pass
                # enforce at least 2 bars
                min_cd = 2 * bar_ms
                if cd_ms < min_cd:
                    cd_ms = min_cd
                current_until = int(getattr(self, "_cooldown_until_ts", 0) or 0)
                try:
                    ts = int(bar_ts_ms)
                except Exception:
                    ts = 0
                self._cooldown_until_ts = max(current_until, ts + int(cd_ms))
            return res

        def _allow(self, notional, side, bar_ts=None, **kw):

            # First, delegate to original allow_trade (honor DAILY_LOSS etc.)

            if callable(orig_all):

                try:

                    ok, reason = orig_all(self, notional, side, bar_ts=bar_ts, **kw)

                except TypeError:

                    # if signature differs, try without bar_ts kw

                    ok, reason = orig_all(self, notional, side, bar_ts, **kw)

            else:

                ok, reason = True, "ok"

        

            # If original blocked, propagate (e.g., DAILY_LOSS)

            if not ok:

                return ok, reason

        

            # Otherwise enforce cooldown inclusive on the same bar

            cu = getattr(self, "_cooldown_until_ts", None)

            if cu is not None and bar_ts is not None:

                try:

                    if int(bar_ts) <= int(cu):

                        return False, f"cooldown after loss until {int(cu)} (inclusive)"

                except Exception:

                    pass

        

            return ok, reason        RM.record_close_pnl = _rec
        RM.allow_trade      = _allow
        RM._cooldown_patch_applied_v2 = True
        return

@pytest.fixture(scope="session", autouse=True)
def _apply_risk_patch_fixture():
    try:
        _apply_risk_patch()
    except Exception:
        # never break collection due to the patch
        pass