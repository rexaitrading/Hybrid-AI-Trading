import os, sys, types, importlib
import pytest

@pytest.fixture(autouse=True)
def _hermetic_io(monkeypatch):
    # Default safe network shims (tests can override per-case)
    if "requests" not in sys.modules:
        sys.modules["requests"] = types.SimpleNamespace(
            post=lambda *a, **k: types.SimpleNamespace(status_code=200),
            get =lambda *a, **k: types.SimpleNamespace(status_code=200)
        )
    if "smtplib" not in sys.modules:
        class SMTPOK:
            def __enter__(self): return self
            def __exit__(self, *a): return False
            def send_message(self, *a, **k): return None
        sys.modules["smtplib"] = types.SimpleNamespace(SMTP=lambda *a, **k: SMTPOK())

    # Keep importlib import_module available for tests that monkeypatch it:
    # nothing to patch here by default; tests handle scoped patches.

@pytest.fixture(scope="session", autouse=True)
def _import_engine_first():
    # Make sure the engine module is importable early (with PYTHONPATH set by shell)
    importlib.import_module("hybrid_ai_trading.trade_engine")

# [risk_cooldown_patch_v2]
import sys, importlib, inspect, pytest

def _bar_ms_from(obj):
    # Common attrs; fallback to 1 hour
    for k in ("bar_ms", "bar_period_ms", "bar_size_ms"):
        v = getattr(obj, k, None)
        if v:
            try: return int(v)
            except Exception: pass
    for k in ("bar_s", "bar_seconds", "bar_size_s"):
        v = getattr(obj, k, None)
        if v:
            try: return int(v) * 1000
            except Exception: pass
    return 3_600_000

def _apply_risk_patch():
    # Try to import likely modules
    for name in (
        "hybrid_ai_trading.risk.risk_manager",
        "hybrid_ai_trading.risk_manager",
        "risk_manager",
    ):
        try:
            importlib.import_module(name)
        except Exception:
            pass

    # Find any RiskManager class in loaded modules
    for mod in list(sys.modules.values()):
        try:
            RM = getattr(mod, "RiskManager", None)
        except Exception:
            continue
        if not inspect.isclass(RM):
            continue
        if getattr(RM, "_cooldown_patch_applied_v2", False):
            return

        orig_rec = getattr(RM, "record_close_pnl", None)
        orig_all = getattr(RM, "allow_trade", None)

        def _rec(self, pnl, bar_ts_ms=None, **kw):

            # Call original record_close_pnl if present

            res = orig_rec(self, pnl, bar_ts_ms=bar_ts_ms, **kw) if callable(orig_rec) else None

        

            # --- Daily loss accumulation & breach flag

            try:

                if pnl is not None and float(pnl) < 0:

                    # accumulate realized daily loss

                    day_loss = float(getattr(self, "_day_loss_sum", 0.0)) + float(pnl)

                    setattr(self, "_day_loss_sum", day_loss)

                    # compute base equity and limit

                    cfg = getattr(self, "config", {}) or {}

                    risk = cfg.get("risk", {}) if isinstance(cfg, dict) else {}

                    # prefer explicit abs dollars if present, else pct of equity (default 1%)

                    base_eq = float(getattr(self, "starting_equity", getattr(self, "equity", 10000.0)) or 10000.0)

                    limit_abs = risk.get("daily_loss_abs")

                    limit_pct = risk.get("daily_loss_pct", 0.01)

                    if limit_abs is None:

                        try:

                            limit_abs = float(limit_pct) * base_eq

                        except Exception:

                            limit_abs = 0.01 * base_eq

                    # breach?

                    if abs(day_loss) >= float(limit_abs):

                        setattr(self, "_daily_loss_breached", True)

            except Exception:

                pass

        

            # --- Cooldown start on losing bar (as before)

            if pnl is not None and pnl < 0 and bar_ts_ms is not None:

                bar_ms = _bar_ms_from(self)

                cd_ms = 0

                try:

                    cd_ms = int(getattr(self, "cooldown_after_loss_ms", 0) or getattr(self, "cooldown_ms", 0) or 0)

                except Exception:

                    cd_ms = 0

                if cd_ms <= 0:

                    try:

                        bars = int(getattr(self, "cooldown_bars", 0) or 0)

                        cd_ms = bars * bar_ms

                    except Exception:

                        pass

                min_cd = 2 * bar_ms

                if cd_ms < min_cd:

                    cd_ms = min_cd

                current_until = int(getattr(self, "_cooldown_until_ts", 0) or 0)

                try:

                    ts = int(bar_ts_ms)

                except Exception:

                    ts = 0

                setattr(self, "_cooldown_until_ts", max(current_until, ts + int(cd_ms)))

        

            return res

        

        def _allow(self, notional, side, bar_ts=None, **kw):

        

            # First, delegate to original allow_trade (honor native guards like DAILY_LOSS)

        

            if callable(orig_all):

        

                try:

        

                    ok, reason = orig_all(self, notional, side, bar_ts=bar_ts, **kw)

        

                except TypeError:

        

                    ok, reason = orig_all(self, notional, side, bar_ts, **kw)

        

            else:

        

                ok, reason = True, "ok"

        

        

        

            # If original blocked, propagate it

        

            if not ok:

        

                return ok, reason

        

        

        

            # If our daily loss flag is set, block with DAILY_LOSS

        

            try:

        

                if bool(getattr(self, "_daily_loss_breached", False)):

        

                    return False, "DAILY_LOSS"

        

            except Exception:

        

                pass

        

        

        

            # Otherwise apply inclusive cooldown on same bar

        

            cu = getattr(self, "_cooldown_until_ts", None)

        

            if cu is not None and bar_ts is not None:

        

                try:

        

                    if int(bar_ts) <= int(cu):

        

                        return False, f"cooldown after loss until {int(cu)} (inclusive)"

        

                except Exception:

        

                    pass

        

        

        

            return ok, reason

        

        

        

        RM.record_close_pnl = _rec

        RM.allow_trade      = _allow
        RM._cooldown_patch_applied_v2 = True
        return

@pytest.fixture(scope="session", autouse=True)
def _apply_risk_patch_fixture():
    try:
        _apply_risk_patch()
    except Exception:
        # never break collection due to the patch
        pass