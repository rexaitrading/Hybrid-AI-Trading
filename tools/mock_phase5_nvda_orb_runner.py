# --- NVDA Phase-5 R-based config (autogenerated) ----------------------
# These values come from docs/SPY_ORB_Phase5_Config.md:
# - 1R ~= 0.319% (from latest replay)
# - TP_R = +2.2R  (~+0.7% on a similar day)
# - SL_R = -0.6R  (~-0.19% per full stop, RR ~= 3.7:1)

SPY_ORB_TP_R = 2.2
SPY_ORB_SL_R = -0.6


def get_spy_orb_tp_sl_r():
    """
    Return the current R-based TP/SL for SPY ORB Phase-5.

    This is a pure configuration hook. Strategy logic can call this to
    decide its TP/SL multiples without hard-coding magic numbers.
    """
    return SPY_ORB_TP_R, SPY_ORB_SL_R

# ------------------------------------------------------------------------

"""
Mock NVDA Phase-5 + Risk + no-averaging-down runner.

- Reads trades from logs/nvda_phase5_replay_gated.jsonl
  (already contains pnl_gate Phase-5 flags).
- For each trade:
    * Ask RiskManager if trade is allowed.
    * Apply Phase-5 "no averaging down" rule.
    * Combine decisions into additional JSONL fields.
- Writes enriched records to logs/nvda_phase5_orb_phase5_risk.jsonl
  (original replay_gated.jsonl is left untouched).
"""

import json
from pathlib import Path
from typing import Any, Dict, List
from hybrid_ai_trading.risk.risk_phase5_paper_adapter import Phase5RiskAdapter

# NOTE: PYTHONPATH must include "src" so this import works:
#   $env:PYTHONPATH = "<repo>\src"
try:
    from hybrid_ai_trading.risk_manager_phase5_bridge import RiskManager  # type: ignore
except Exception:  # pragma: no cover - fallback stub
    class RiskManager:  # type: ignore[no-redef]
        """
        Fallback stub if real RiskManager cannot be imported.

        This keeps the runner usable for offline experiments
        without crashing, but you should fix the import so that
        the real RiskManager is used.
        """
        def __init__(self, *args: Any, **kwargs: Any) -> None:
            self._config = {"stub": True}

        def check_trade(self, trade: Dict[str, Any]) -> Dict[str, Any]:
            return {
                "allowed": True,
                "reason": "risk_layer_stub_not_wired",
            }

try:
    from hybrid_ai_trading.tools.phase5_gating_helpers import (
        phase5_no_averaging_down_for_symbol,
    )  # type: ignore
except Exception:
    def phase5_no_averaging_down_for_symbol_bridge(
        state: Dict[str, Any],
        trade: Dict[str, Any],
    ) -> Dict[str, Any]:  # type: ignore[no-redef]
        """
        Fallback stub if real helper cannot be imported.

        Always allows, but records a stub reason.
        """
        return {
            "allowed": True,
            "reason": "no_avg_stub_ok",
        }


ROOT = Path(__file__).resolve().parents[1]
LOGS_DIR = ROOT / "logs"

INPUT_JSONL = LOGS_DIR / "nvda_phase5_replay_gated.jsonl"
OUTPUT_JSONL = LOGS_DIR / "nvda_phase5_orb_phase5_risk.jsonl"


def load_trades(path: Path) -> List[Dict[str, Any]]:
    if not path.exists():
        raise FileNotFoundError(f"Missing input JSONL: {path}")
    trades: List[Dict[str, Any]] = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            trades.append(json.loads(line))
    return trades


def save_trades(path: Path, trades: List[Dict[str, Any]]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        for rec in trades:
            f.write(json.dumps(rec, ensure_ascii=False))
            f.write("\n")


def main() -> None:
    print("[PHASE5_NVDA] Loading NVDA Phase-5 replay trades from JSONL...")
    trades = load_trades(INPUT_JSONL)
    print(f"[PHASE5_NVDA] Loaded {len(trades)} trades from {INPUT_JSONL.name}")

    # ---- RiskManager wiring ----
    # TODO: if your real RiskManager requires specific parameters
    # (e.g. max_daily_loss_pct, cooldown_bars, etc.), plug them in here.
    risk = Phase5RiskAdapter()

    # State object you can expand later (per-symbol open/close info, etc.).
    open_state: Dict[str, Any] = {}

    enriched: List[Dict[str, Any]] = []

    combined_blocked = 0
    combined_allowed = 0

    for trade in trades:
        symbol = trade.get("symbol", "SPY")
        regime = trade.get("regime", "SPY_ORB_REPLAY")
        ts = trade.get("entry_ts") or trade.get("ts")

        # Existing Phase-5 decision from pnl_gate
        base_phase5_allowed = bool(trade.get("phase5_sim_allow", True))
        base_phase5_reason = str(trade.get("phase5_sim_reason", "kelly_gate"))

        # ---- 1) RiskManager decision ----
        risk_decision = risk.check_trade(trade=trade)  # type: ignore[arg-type]
        risk_allowed = bool(risk_decision.get("allowed", True))
        risk_reason = str(risk_decision.get("reason", "risk_ok"))

        # ---- 2) No-averaging-down decision ----
        na_decision = phase5_no_averaging_down_for_symbol_bridge(
            open_state,
            trade,
        )
        na_allowed = bool(na_decision.get("allowed", True))
        na_reason = str(na_decision.get("reason", "no_averaging_ok"))

        # ---- 3) Combined Phase-5 decision (additive, non-destructive) ----
        combined_allowed_flag = (
            base_phase5_allowed and risk_allowed and na_allowed
        )

        if combined_allowed_flag:
            combined_allowed += 1
        else:
            combined_blocked += 1
            print(
                f"PHASE5 COMBINED BLOCKED: {symbol} at {ts} "
                f"(base={base_phase5_allowed}, risk={risk_allowed}, na={na_allowed})"
            )

        # Attach detailed flags *without* overwriting original base flags
        trade["phase5_base_allowed"] = base_phase5_allowed
        trade["phase5_base_reason"] = base_phase5_reason

        trade["phase5_risk_allowed"] = risk_allowed
        trade["phase5_risk_reason"] = risk_reason

        trade["phase5_no_avg_allowed"] = na_allowed
        trade["phase5_no_avg_reason"] = na_reason

        trade["phase5_combined_allowed"] = combined_allowed_flag
        trade["phase5_combined_reason"] = (
            f"base={base_phase5_reason};"
            f" risk={risk_reason};"
            f" no_avg={na_reason}"
        )

        # Keep original phase5_allowed/phase5_reason untouched for now.
        enriched.append(trade)

    print(
        f"Summary (COMBINED): symbol=NVDA total_trades={len(enriched)} "
        f"blocked={combined_blocked} allowed={combined_allowed}"
    )
    print(f"[JSONL_PHASE5] Writing enriched records to {OUTPUT_JSONL}")
    save_trades(OUTPUT_JSONL, enriched)
    print("[JSONL_PHASE5] Done.")


if __name__ == "__main__":
    main()

# --- Phase-5 bridge-backed no-averaging helper (SPY ORB replay) ---

def phase5_no_averaging_down_for_symbol_bridge(
    state: Dict[str, Any],
    trade: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Use RiskManagerPhase5.can_add as the Phase-5 no-averaging gate.

    This is a temporary inline helper for the SPY ORB replay runner.
    Later it can be moved into hybrid_ai_trading.tools.phase5_gating_helpers.
    """
    from hybrid_ai_trading.risk_manager_phase5_bridge import (
        RiskManagerPhase5,
        PositionSnapshot,
        AddRequest,
    )

    # In a replay, we only have a single "trade" event. We approximate a
    # simple position + proposed add based on that trade.
    bridge = RiskManagerPhase5()

    symbol = str(trade.get("symbol", "SPY"))
    side_raw = str(trade.get("side", "long")).upper()
    side = "LONG" if "SHORT" not in side_raw else "SHORT"

    # Approximate PnL in basis points from gross_pnl_pct (if present).
    pnl_pct = float(trade.get("gross_pnl_pct", 0.0))
    unrealized_pnl_bp = pnl_pct * 10000.0

    # Approximate notional from entry_price (1-share notionally).
    entry_price = float(trade.get("entry_price", 0.0))
    if entry_price <= 0.0:
        notional = 1.0
    else:
        notional = entry_price

    position = PositionSnapshot(
        symbol=symbol,
        side=side,
        unrealized_pnl_bp=unrealized_pnl_bp,
        notional=notional,
    )

    # Pretend we want to add the same notional again (1-share logic).
    add = AddRequest(
        additional_notional=notional,
        additional_shares_round_trip=1,
    )

    allowed = bridge.can_add(position, add)
    reason = "phase5_bridge_can_add" if allowed else "phase5_bridge_blocked"

    return {
        "allowed": allowed,
        "reason": reason,
    }
