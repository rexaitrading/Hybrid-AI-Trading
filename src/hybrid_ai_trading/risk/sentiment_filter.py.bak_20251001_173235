"""
Sentiment Filter (Hybrid AI Quant Pro v15.0 – AAA Grade, Fully Covered)
----------------------------------------------------------------------
- Supports VADER (default) and FinBERT sentiment scoring
- Threshold priority: threshold → neutral zone → bias
- Rolling smoothing (history-based averaging)
- Defensive guards for missing/malformed analyzers
- Safe fallbacks when vader/transformers not installed
- Now integrates BenzingaClient for live headlines
"""

import logging
import math
from typing import List, Optional

logger = logging.getLogger(__name__)

# Safe optional imports
try:
    from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
except ImportError:
    SentimentIntensityAnalyzer = None
    logger.warning(" vaderSentiment not installed  VADER unavailable")

try:
    from transformers import pipeline
except ImportError:
    pipeline = None
    logger.warning(" transformers not installed  FinBERT unavailable")

from dotenv import load_dotenv
from hybrid_ai_trading.data.clients.benzinga_client import BenzingaClient

# Ensure .env is loaded once
load_dotenv()


# ------------------------------------------------------------------
# Load defaults from config.yaml
import yaml
try:
    with open("config/config.yaml", "r") as f:
        _cfg = yaml.safe_load(f) or {}
    _sf_cfg = _cfg.get("sentiment_filter", {})
except Exception:
    _sf_cfg = {}

DEFAULT_THRESHOLD = float(_sf_cfg.get("threshold", 0.6))
DEFAULT_NEUTRAL = float(_sf_cfg.get("neutral_zone", 0.25))
DEFAULT_SMOOTH = int(_sf_cfg.get("smoothing", 3))
DEFAULT_MODEL = _sf_cfg.get("model", "vader")
DEFAULT_ENABLED = bool(_sf_cfg.get("enabled", True))

class SentimentFilter:
    def __init__(
        self,
        enabled: bool = True,
        threshold: float = 0.8,
        neutral_zone: float = 0.2,
        bias: str = "none",
        model: str = "vader",
        smoothing: int = 1,
    ):
        self.enabled = enabled
        self.threshold = threshold
        self.neutral_zone = neutral_zone
        self.bias = bias
        self.model = model
        self.smoothing = max(1, smoothing)
        self.history: List[float] = []

        if not enabled:
            self.analyzer = None
            return

        # --- Safe model selection ---
        if model == "vader" and SentimentIntensityAnalyzer:
            self.analyzer = SentimentIntensityAnalyzer()
        elif model == "finbert" and pipeline:
            try:
                self.analyzer = pipeline("sentiment-analysis", model="ProsusAI/finbert")
            except Exception as e:
                self.analyzer = None
                logger.warning(f" SentimentFilter fallback: FinBERT unavailable  {e}")
        elif model not in ("vader", "finbert"):
            raise ValueError(f"Unknown model: {model}")
        else:
            self.analyzer = None
            logger.warning(f" SentimentFilter fallback: model={model} unavailable")

        logger.info(
            f" SentimentFilter initialized | model={self.model} | "
            f"threshold={self.threshold} | neutral_zone={self.neutral_zone} | "
            f"bias={self.bias} | smoothing={self.smoothing}"
        )

    # ------------------------------------------------------------------
    def score(self, text: str) -> float:
        """Return sentiment score  [0,1]."""
        if not self.enabled:
            return 0.5
        if self.analyzer is None:
            logger.debug("ℹ Analyzer=None  default neutral 0.5")
            return 0.5

        try:
            if self.model == "vader":
                if not hasattr(self.analyzer, "polarity_scores"):
                    logger.error(" VADER analyzer missing polarity_scores  neutral 0.5")
                    return 0.5
                result = self.analyzer.polarity_scores(text)
                if not isinstance(result, dict) or "compound" not in result:
                    logger.error(" Invalid VADER output  0.0")
                    return 0.0
                compound = float(result.get("compound", 0.0))
                if math.isnan(compound):
                    logger.error(" Compound is NaN  0.0")
                    return 0.0
                normalized = (compound + 1) / 2

            elif self.model == "finbert":
                if not callable(self.analyzer):
                    logger.error(" FinBERT analyzer not callable  neutral 0.5")
                    return 0.5
                result = self.analyzer(text)
                if not isinstance(result, list) or not result:
                    logger.error(" FinBERT output not list  0.0")
                    return 0.0
                res = result[0]
                if not isinstance(res, dict) or "label" not in res or "score" not in res:
                    logger.error(" Malformed FinBERT dict  0.0")
                    return 0.0
                label, sc = res["label"].lower(), float(res["score"])
                if label == "positive":
                    normalized = sc
                elif label == "negative":
                    normalized = 1 - sc
                else:
                    normalized = 0.5
            else:
                return 0.5
        except Exception as e:
            logger.error(f" Sentiment scoring failed: {e}")
            return 0.0

        # --- Smoothing ---
        if self.smoothing > 1:
            self.history.append(normalized)
            if len(self.history) > self.smoothing:
                self.history.pop(0)
            return sum(self.history) / len(self.history)

        return normalized

    # ------------------------------------------------------------------
    def allow_trade(self, headline: str, side: str = "BUY", precomputed_score: Optional[float] = None) -> bool:
        """Return True if trade is allowed under sentiment rules."""
        if not self.enabled:
            return True
        if self.analyzer is None:
            logger.debug("ℹ Analyzer=None  allow all trades")
            return True

        score = precomputed_score if precomputed_score is not None else self.score(headline)
        side = side.upper()

        if side == "HOLD":
            return True
        if side not in {"BUY", "SELL", "HOLD"}:
            logger.debug("ℹ Unknown side  allowed")
            return True

        if score < self.threshold:
            logger.warning(
                f" Emotional Filter blocked {side} | score={score:.2f} | threshold={self.threshold}"
            )
            return False

        # compare to neutral baseline 0.5
        if abs(score - 0.5) <= self.neutral_zone:
            logger.debug(f"ℹ Score={score:.2f} inside neutral zone  allowed")
            return True

        if self.bias == "bullish" and side == "SELL":
            logger.warning(f" Bullish bias blocks SELL | score={score:.2f}")
            return False
        if self.bias == "bearish" and side == "BUY":
            logger.warning(f" Bearish bias blocks BUY | score={score:.2f}")
            return False

        return True


# Demo block: fetch news & run sentiment if executed directly
if __name__ == "__main__":
    client = BenzingaClient()
    news = client.get_news("AAPL,TSLA", limit=5)
    filt = SentimentFilter(model="vader", threshold=0.6, neutral_zone=0.25, smoothing=3)

    for story in news:
        headline = story.get("title", "")
        sc = filt.score(headline)
        allowed = filt.allow_trade(headline, side="BUY")
        print(f"[{story.get('created')}] {headline} | Score={sc:.2f} | Allow={allowed} | URL={story.get('url')}")
