from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Optional, Any, Dict

logger = logging.getLogger(__name__)

# Optional deps — tests may monkeypatch these names to None
try:
    from nltk.sentiment import SentimentIntensityAnalyzer  # type: ignore
except Exception:  # pragma: no cover
    SentimentIntensityAnalyzer = None  # type: ignore

try:
    from transformers import pipeline  # type: ignore
except Exception:  # pragma: no cover
    pipeline = None  # type: ignore


@dataclass
class SentimentFilter:
    enabled: bool = True
    model: str = "vader"  # "vader" | "hf" (transformers)
    threshold: float = 0.0  # accepted for config compatibility
    analyzer: Optional[Any] = None

    def __post_init__(self) -> None:
        self._init_analyzer()

    def _init_analyzer(self) -> None:
        """Initialize analyzer based on model; if unavailable, fall back to neutral."""
        m = (self.model or "vader").lower()

        if not self.enabled:
            self.analyzer = None
            return

        if m == "vader":
            if SentimentIntensityAnalyzer is not None:
                try:
                    self.analyzer = SentimentIntensityAnalyzer()
                    return
                except Exception:  # pragma: no cover
                    self.analyzer = None
            logger.warning(
                "Analyzer unavailable for model=vader; fallback to neutral scoring (analyzer=None)."
            )
            self.analyzer = None
            return

        if m in ("hf", "transformers", "bert", "distilbert"):
            if pipeline is not None:
                try:
                    self.analyzer = pipeline("sentiment-analysis")
                    return
                except Exception:  # pragma: no cover
                    self.analyzer = None
            logger.warning(
                "Analyzer unavailable for model=hf; fallback to neutral scoring (analyzer=None)."
            )
            self.analyzer = None
            return

        # Unknown model → neutral fallback with explicit wording
        logger.warning(
            "Unknown sentiment model=%s; fallback to neutral scoring (analyzer=None).", m
        )
        self.analyzer = None

    def score(self, text: str) -> float:
        """
        Return sentiment score in [-1, 1].
        - Disabled or missing analyzer → 0.0 (neutral fallback)
        - VADER: compound score
        - HF pipeline: map POSITIVE to +score, NEGATIVE to -score (else 0)
        NOTE: `threshold` is accepted for config compatibility; this method returns the raw score.
        """
        if not self.enabled or not text:
            return 0.0
        if self.analyzer is None:
            return 0.0

        # VADER path
        if hasattr(self.analyzer, "polarity_scores"):
            try:
                return float(self.analyzer.polarity_scores(text).get("compound", 0.0))
            except Exception:
                logger.exception("VADER scoring failed; fallback to neutral (0.0).")
                return 0.0

        # HF pipeline path
        try:
            out = self.analyzer(text)
            if not out:
                return 0.0
            r0: Dict[str, Any] = out[0]
            label = str(r0.get("label", "")).upper()
            val = float(r0.get("score", 0.0))
            if "POS" in label:
                return +val
            if "NEG" in label:
                return -val
            return 0.0
        except Exception:
            logger.exception("HF scoring failed; fallback to neutral (0.0).")
            return 0.0
