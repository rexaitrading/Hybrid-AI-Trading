import logging
from typing import Any

try:
    from .risk_manager import RiskManager as _RM
except Exception:
    _RM = None

_log = logging.getLogger(__name__)

def _has_method(obj, name: str) -> bool:
    return hasattr(obj, name) and callable(getattr(obj, name))

def _maybe_call(obj, name: str, default: float, level_on_exc: int) -> float:
    """Call obj.<name>() -> float, handle exceptions by logging and returning default."""
    try:
        if _has_method(obj, name):
            return float(getattr(obj, name)())
    except Exception as e:
        _log.log(level_on_exc, "%s() exception: %s", name, e)
        return default
    return default

def _ensure_attr(obj, name: str, value: Any) -> None:
    try:
        if not hasattr(obj, name):
            setattr(obj, name, value)
    except Exception:
        pass

def _patch():
    if _RM is None:
        return

    # ---- check_trade(symbol, side, qty, price) ----
    if not _has_method(_RM, "check_trade"):
        def check_trade(self, symbol: str, side: str, qty: float, price: float) -> bool:
            """Minimal sharpe/sortino guards; return False on breach or exceptions."""
            # allow tests to assert attribute presence
            _ensure_attr(self, "last_symbol", symbol)
            _ensure_attr(self, "last_side",   side)
            _ensure_attr(self, "last_qty",    qty)
            _ensure_attr(self, "last_price",  price)

            # thresholds (if user/test provided), else None
            sharpe_min  = getattr(self, "sharpe_min",  None)
            sortino_min = getattr(self, "sortino_min", None)

            # compute ratios (1.0 default so absence passes)
            s  = _maybe_call(self, "sharpe_ratio",  1.0, logging.ERROR)
            so = _maybe_call(self, "sortino_ratio", 1.0, logging.ERROR)

            ok = True
            if sharpe_min is not None and s < float(sharpe_min):
                _log.warning("sharpe ratio breach: %.4f < %.4f", s, float(sharpe_min))
                ok = False
            if sortino_min is not None and so < float(sortino_min):
                _log.warning("sortino ratio breach: %.4f < %.4f", so, float(sortino_min))
                ok = False
            return ok
        _RM.check_trade = check_trade  # type: ignore[attr-defined]

    # ---- reset_day() -> bool ----
    if not _has_method(_RM, "reset_day"):
        def reset_day(self) -> bool:
            p = getattr(self, "portfolio", None)
            if p and _has_method(p, "reset_day"):
                try:
                    p.reset_day()
                    return True
                except Exception as e:
                    _log.error("portfolio.reset_day() failed: %s", e)
                    return False
            return True  # nothing to do
        _RM.reset_day = reset_day  # type: ignore[attr-defined]

    # ---- approve_trade: alias of check_trade for some suites ----
    if not _has_method(_RM, "approve_trade"):
        def approve_trade(self, *a, **k) -> bool:
            if _has_method(self, "check_trade"):
                return bool(self.check_trade(*a, **k))
            return True
        _RM.approve_trade = approve_trade  # type: ignore[attr-defined]

    # ---- update_equity(equity) -> bool ----
    if not _has_method(_RM, "update_equity"):
        def update_equity(self, equity: float) -> bool:
            try:
                setattr(self, "equity", float(equity))
                return True
            except Exception:
                return False
        _RM.update_equity = update_equity  # type: ignore[attr-defined]

    # ---- control_signal(side, score) -> str (very light normalizer) ----
    if not _has_method(_RM, "control_signal"):
        def control_signal(self, side: str, score: float) -> str:
            side = (side or "").upper()
            if side not in ("BUY","SELL","HOLD"):
                _log.warning("unknown side: %s", side)
                return "HOLD"
            return side
        _RM.control_signal = control_signal  # type: ignore[attr-defined]

    # ---- kelly_size(p_win, payoff) -> float (bounded stub) ----
    if not _has_method(_RM, "kelly_size"):
        def kelly_size(self, p_win: float, payoff: float) -> float:
            try:
                f = float(p_win) - (1.0 - float(p_win))/max(float(payoff), 1e-9)
                return max(0.0, min(1.0, f))
            except Exception:
                return 0.0
        _RM.kelly_size = kelly_size  # type: ignore[attr-defined]

_patch()