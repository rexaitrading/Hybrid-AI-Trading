"""
RiskManager (Hybrid AI Quant Pro Ã¢â‚¬â€œ OE Grade Halts)
--------------------------------------------------
- Daily loss cap (% of day-start equity) [TOP PRIORITY]
- Max drawdown cap (rolling peak)        [TOP PRIORITY]
- Max trades/day
- Per-trade notional cap
- Max consecutive losers  cooldown (halt for N bars)
- Fail-closed option + FORCE_RISK_HALT env override for demos
- Persistent state in logs/risk_state.json
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Any, Tuple
import json, os
from datetime import datetime, timezone


@dataclass
class RiskConfig:
    day_loss_cap_pct: float = 0.02            # 2% of day-start equity
    per_trade_notional_cap: Optional[float] = None
    max_trades_per_day: int = 6
    max_consecutive_losers: int = 3
    cooldown_bars: int = 2                    # bars to halt after max losers
    max_drawdown_pct: float = 0.08            # 8% from rolling equity peak
    fail_closed: bool = True
    state_path: str = os.path.join("logs", "risk_state.json")
    base_equity_fallback: float = 10_000.0    # used if day_start_equity unknown


class RiskManager:
    def __init__(self, cfg: Optional[RiskConfig] = None) -> None:
        self.cfg = cfg or RiskConfig()

        # live snapshot fields (exposed to logger / runner)
        self.daily_loss_breached: bool = False
        self.current_drawdown: Optional[float] = None
        self.current_exposure: Optional[float] = None
        self.current_leverage: Optional[float] = None

        self._state: Dict[str, Any] = self._load_state()
        self._state.setdefault("day", self._today())
        self._state.setdefault("day_start_equity", float(self.cfg.base_equity_fallback))
        self._state.setdefault("day_realized_pnl", 0.0)
        self._state.setdefault("trades_today", 0)
        self._state.setdefault("consecutive_losers", 0)
        self._state.setdefault("halted_until_bar_ts", None)
        self._state.setdefault("halted_reason", None)
        # initialize rolling peak to known anchor
        self._state.setdefault("rolling_peak_equity", float(self._state.get("day_start_equity", self.cfg.base_equity_fallback)))
        self._state.setdefault("last_trade_bar_ts", None)
        self._save_state()

    # ------------------------- persistence -------------------------
    def _load_state(self) -> Dict[str, Any]:
        try:
            p = self.cfg.state_path
            if os.path.exists(p) and os.path.getsize(p) > 0:
                with open(p, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, dict):
                        return data
        except Exception:
            pass
        return {}

    def _save_state(self) -> None:
        """Persist state (defensive: swallow any IO errors)."""
        try:
            os.makedirs(os.path.dirname(self.cfg.state_path), exist_ok=True)
            with open(self.cfg.state_path, "w", encoding="utf-8") as f:
                json.dump(self._state, f)
        except Exception:
            # swallow IO errors (permissions, bad path, race)
            pass

    # ------------------------- utilities --------------------------
    @staticmethod
    def _today() -> str:
        return datetime.now(timezone.utc).strftime("%Y-%m-%d")

    def reset_day_if_needed(self, bar_ts_ms: int) -> None:
        today = self._today()
        if self._state.get("day") != today:
            self._state["day"] = today
            # carry forward last equity as new day start equity
            self._state["day_start_equity"] = float(self._state.get("last_equity", self.cfg.base_equity_fallback))
            self._state["day_realized_pnl"] = 0.0
            self._state["trades_today"] = 0
            self._state["consecutive_losers"] = 0
            self._state["halted_until_bar_ts"] = None
            self._state["halted_reason"] = None
            # reset rolling peak to the new anchor (prevents stale peak across days)
            self._state["rolling_peak_equity"] = float(self._state["day_start_equity"])
            self._save_state()

    def update_equity(self, equity: float) -> None:
        equity = float(equity)
        peak = float(self._state.get("rolling_peak_equity") or equity)
        if equity > peak:
            peak = equity
        self._state["rolling_peak_equity"] = peak
        self._state["last_equity"] = equity
        dd = 0.0 if peak <= 0 else (peak - equity) / peak
        self.current_drawdown = dd
        self._save_state()

    def set_exposure(self, exposure: Optional[float]) -> None:
        self.current_exposure = None if exposure is None else float(exposure)

    def set_leverage(self, leverage: Optional[float]) -> None:
        self.current_leverage = None if leverage is None else float(leverage)

    def record_close_pnl(self, pnl: float, bar_ts_ms: Optional[int] = None) -> None:
        """Call when a position is closed to update daily pnl and losers streak."""
        pnl = float(pnl)
        self._state["day_realized_pnl"] = float(self._state.get("day_realized_pnl", 0.0)) + pnl
        if pnl < 0:
            self._state["consecutive_losers"] = int(self._state.get("consecutive_losers", 0)) + 1
            # mark the bar for cooldown window start; reason remains losers
            if self._state["consecutive_losers"] >= self.cfg.max_consecutive_losers and bar_ts_ms:
                self._state["halted_until_bar_ts"] = int(bar_ts_ms)
                self._state["halted_reason"] = "MAX_CONSECUTIVE_LOSERS"
        else:
            self._state["consecutive_losers"] = 0
        self._save_state()

    # ------------------------- core gate (PRIORITIZED) -------------------------
    def allow_trade(self, *, notional: float, side: str, bar_ts: int) -> Tuple[bool, Optional[str]]:
        """
        Returns (ok, reason). Priority:
        1) FORCE_RISK_HALT
        2) DAILY_LOSS
        3) MAX_DRAWDOWN
        4) COOLDOWN (losers)
        5) TRADES_PER_DAY
        6) NOTIONAL_CAP
        """
        try:
            self.reset_day_if_needed(bar_ts)

            # 1) Demo/test override
            force = os.getenv("FORCE_RISK_HALT", "").upper().strip()
            if force:
                self._state["halted_reason"] = force
                self._state["halted_until_bar_ts"] = int(bar_ts)
                self._save_state()
                return False, force

            # 2) Daily loss cap (TOP priority)
            start_eq = float(self._state.get("day_start_equity", self.cfg.base_equity_fallback))
            day_pnl = float(self._state.get("day_realized_pnl", 0.0))
            daily_cap = -abs(self.cfg.day_loss_cap_pct) * start_eq
            if day_pnl <= daily_cap:
                self.daily_loss_breached = True
                self._state["halted_reason"] = "DAILY_LOSS"
                self._state["halted_until_bar_ts"] = int(bar_ts)
                self._save_state()
                return False, "DAILY_LOSS"
            self.daily_loss_breached = False

            # 3) Max drawdown (TOP priority)
            if self.current_drawdown is not None and self.current_drawdown >= self.cfg.max_drawdown_pct:
                self._state["halted_reason"] = "MAX_DRAWDOWN"
                self._state["halted_until_bar_ts"] = int(bar_ts)
                self._save_state()
                return False, "MAX_DRAWDOWN"

            # 4) Cooldown after consecutive losers
            halted_until = self._state.get("halted_until_bar_ts")
            if halted_until is not None:
                # Keeps your existing barsms conversion (1 bar = 3600_000 ms)
                if bar_ts <= (int(halted_until) + self.cfg.cooldown_bars * 3600_000):
                    return False, (self._state.get("halted_reason") or "COOLDOWN")
                else:
                    # cooldown expired; clear flags
                    self._state["halted_until_bar_ts"] = None
                    self._state["halted_reason"] = None
                    self._save_state()

            # 5) Max trades per day
            if int(self._state.get("trades_today", 0)) >= int(self.cfg.max_trades_per_day):
                return False, "TRADES_PER_DAY"

            # 6) Per-trade notional cap
            if self.cfg.per_trade_notional_cap is not None and float(notional) > float(self.cfg.per_trade_notional_cap):
                return False, "NOTIONAL_CAP"

            return True, None

        except Exception:
            # Fail-closed if configured
            if self.cfg.fail_closed:
                return False, "EXCEPTION"
            return True, None

    def on_fill(self, *, side: str, qty: float, px: float, bar_ts: int) -> None:
        """Call after a fill to bump counters."""
        self._state["trades_today"] = int(self._state.get("trades_today", 0)) + 1
        self._state["last_trade_bar_ts"] = int(bar_ts)
        self._save_state()

    # ------------- snapshot for logger ---------------------------------
    def snapshot(self) -> Dict[str, Any]:
        return {
            "daily_loss_breached": bool(self.daily_loss_breached),
            "drawdown": self.current_drawdown,
            "exposure": self.current_exposure,
            "leverage": self.current_leverage,
            "day": self._state.get("day"),
            "trades_today": self._state.get("trades_today"),
            "cons_losers": self._state.get("consecutive_losers"),
            "halted_reason": self._state.get("halted_reason"),
        }
