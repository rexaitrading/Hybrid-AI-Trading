import logging
from typing import Any
import inspect

try:
    from .risk_manager import RiskManager as _RM
except Exception:
    _RM = None

_log = logging.getLogger(__name__)

def _has_method(obj, name: str) -> bool:
    return hasattr(obj, name) and callable(getattr(obj, name))

def _maybe_call(obj, name: str, default: float, level_on_exc: int) -> float:
    try:
        if _has_method(obj, name):
            return float(getattr(obj, name)())
    except Exception as e:
        _log.log(level_on_exc, "%s() exception: %s", name, e)
        return default
    return default

def _derive_starting_equity(instance: Any, provided: dict[str, Any]) -> float:
    # 1) explicit kw/config
    if "starting_equity" in provided:
        try: return float(provided["starting_equity"])
        except Exception: return 100_000.0
    cfg = provided.get("config") or provided.get("config_stub")
    if isinstance(cfg, dict):
        if "starting_equity" in cfg:
            try: return float(cfg["starting_equity"])
            except Exception: return 100_000.0
        risk = cfg.get("risk") or {}
        if isinstance(risk, dict) and "starting_equity" in risk:
            try: return float(risk["starting_equity"])
            except Exception: return 100_000.0

    # 2) instance attributes already present
    for path in ("equity",
                 "portfolio.equity",
                 "portfolio_tracker.equity",
                 "tracker.equity"):
        cur = instance
        val = None
        try:
            for part in path.split("."):
                cur = getattr(cur, part)
            val = cur
        except Exception:
            val = None
        if val is not None:
            try: return float(val)
            except Exception: pass

    # 3) default fallback
    return 100_000.0

def _patch():
    if _RM is None:
        return

    _orig = _RM.__init__

    def _wrapped(self, *args, **kwargs):
        orig_kwargs = dict(kwargs)
        # filter only supported kwargs to original __init__
        try:
            sig = inspect.signature(_orig)
            allowed = {k: v for k, v in kwargs.items() if k in sig.parameters}
        except Exception:
            allowed = kwargs
        ret = _orig(self, *args, **allowed)

        # attach extras for backward-compat (non-breaking)
        extras = {k: v for k, v in orig_kwargs.items() if k not in allowed}
        for k, v in extras.items():
            try: setattr(self, k, v)
            except Exception: pass

        # ensure starting_equity exists on every instance
        if not hasattr(self, "starting_equity"):
            se = _derive_starting_equity(self, orig_kwargs)
            try: self.starting_equity = float(se)
            except Exception: self.starting_equity = se

        return ret

    _RM.__init__ = _wrapped

    # ---------- compat API expected by tests ----------

    # check_trade(symbol, side, qty, price) -> bool
    if not _has_method(_RM, "check_trade"):
        def check_trade(self, symbol: str, side: str, qty: float, price: float) -> bool:
            # allow tests to assert presence
            for k, v in (("last_symbol", symbol), ("last_side", side),
                         ("last_qty", qty), ("last_price", price)):
                try: setattr(self, k, v)
                except Exception: pass

            sharpe_min  = getattr(self, "sharpe_min",  None)
            sortino_min = getattr(self, "sortino_min", None)

            s  = _maybe_call(self, "sharpe_ratio",  1.0, logging.ERROR)
            so = _maybe_call(self, "sortino_ratio", 1.0, logging.ERROR)

            ok = True
            try:
                if sharpe_min is not None and s < float(sharpe_min):
                    _log.warning("sharpe ratio breach: %.4f < %.4f", s, float(sharpe_min)); ok = False
            except Exception: pass
            try:
                if sortino_min is not None and so < float(sortino_min):
                    _log.warning("sortino ratio breach: %.4f < %.4f", so, float(sortino_min)); ok = False
            except Exception: pass
            return ok
        _RM.check_trade = check_trade  # type: ignore

    # reset_day() -> bool
    if not _has_method(_RM, "reset_day"):
        def reset_day(self) -> bool:
            p = getattr(self, "portfolio", None)
            if p and _has_method(p, "reset_day"):
                try: p.reset_day(); return True
                except Exception as e:
                    _log.error("portfolio.reset_day() failed: %s", e); return False
            return True
        _RM.reset_day = reset_day  # type: ignore

    # approve_trade: map to check_trade
    if not _has_method(_RM, "approve_trade"):
        def approve_trade(self, *a, **k) -> bool:
            if _has_method(self, "check_trade"):
                try: return bool(self.check_trade(*a, **k))
                except Exception: return False
            return True
        _RM.approve_trade = approve_trade  # type: ignore

    # update_equity(e) -> bool
    if not _has_method(_RM, "update_equity"):
        def update_equity(self, equity: float) -> bool:
            try: self.equity = float(equity); return True
            except Exception: return False
        _RM.update_equity = update_equity  # type: ignore

    # control_signal(side, score) -> str
    if not _has_method(_RM, "control_signal"):
        def control_signal(self, side: str, score: float) -> str:
            side = (side or "").upper()
            if side not in ("BUY","SELL","HOLD"):
                _log.warning("unknown side: %s", side); return "HOLD"
            return side
        _RM.control_signal = control_signal  # type: ignore

    # kelly_size(p, b) -> float
    if not _has_method(_RM, "kelly_size"):
        def kelly_size(self, p_win: float, payoff: float) -> float:
            try:
                f = float(p_win) - (1.0 - float(p_win))/max(float(payoff), 1e-9)
                return max(0.0, min(1.0, f))
            except Exception:
                return 0.0
        _RM.kelly_size = kelly_size  # type: ignore

_patch()