from __future__ import annotations
import time, functools, logging
from typing import Callable, Iterable, Optional, Type, Any
from .ib_conn import reconnect
from .structured_log import get_logger

_log = get_logger("hybrid_ai_trading.ib.reconnect")

def retry(
    retries: int = 3,
    backoff_sec: float = 1.0,
    retry_on: Iterable[Type[BaseException]] = (TimeoutError, ConnectionError, OSError)
) -> Callable:
    """Generic retry decorator without reconnect (pure python ops)."""
    def deco(fn: Callable) -> Callable:
        @functools.wraps(fn)
        def wrapper(*args, **kwargs):
            last = None
            for i in range(retries + 1):
                try:
                    return fn(*args, **kwargs)
                except tuple(retry_on) as e:
                    last = e
                    _log.warning("retry", extra={"attempt": i, "error": str(e)})
                    if i < retries:
                        time.sleep(backoff_sec * (2 ** i))
            raise last
        return wrapper
    return deco

def with_ib_reconnect(
    retries: int = 2,
    backoff_sec: float = 1.0,
    retry_on: Iterable[Type[BaseException]] = (TimeoutError, ConnectionError, OSError)
) -> Callable:
    """
    Decorator for functions whose first or named 'ib' argument is an IB() instance.
    On failure, it will reconnect and retry the function. Safe for read-only ops and what-if.
    """
    def deco(fn: Callable) -> Callable:
        @functools.wraps(fn)
        def wrapper(*args, **kwargs):
            # find IB instance
            ib = kwargs.get("ib")
            if ib is None and args:
                # if used as method, args[0] might be self; try next positional
                for a in args:
                    if hasattr(a, "isConnected") and hasattr(a, "client"): 
                        ib = a
                        break
            # connection hints (optional) for reconnect()
            host = kwargs.pop("host", None)
            port = kwargs.pop("port", None)
            client_id = kwargs.pop("client_id", None)

            last = None
            for i in range(retries + 1):
                try:
                    return fn(*args, **kwargs)
                except tuple(retry_on) as e:
                    last = e
                    _log.warning("ib_op_retry", extra={"attempt": i, "error": str(e)})
                    if ib is None or i >= retries:
                        break
                    # reconnect and inject back
                    ib = reconnect(ib, host=host, port=port, client_id=client_id)
                    # push updated ib back into kwargs if present
                    if "ib" in kwargs:
                        kwargs["ib"] = ib
                    else:
                        # if positional, replace first IB-like arg
                        new_args = []
                        replaced = False
                        for a in args:
                            if (not replaced) and hasattr(a, "isConnected") and hasattr(a, "client"):
                                new_args.append(ib); replaced = True
                            else:
                                new_args.append(a)
                        args = tuple(new_args)
                    # continue loop
                    time.sleep(backoff_sec * (2 ** i))
            if last:
                raise last
        return wrapper
    return deco