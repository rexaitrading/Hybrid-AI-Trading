# src/hybrid_ai_trading/performance_tracker.py
"""
Performance Tracker (Hybrid AI Quant Pro v21.2 – Hedge Fund OE Grade, AAA Coverage)
----------------------------------------------------------------------------------
- Record trades and equity curve (rolling window)
- Compute win rate, payoff, ROI, Sharpe, Sortino
- Annualized metrics for institutional comparability
- Advanced ratios: Calmar, Omega, Alpha/Beta vs. benchmark
- Track max drawdown and recovery times
- Export audit-ready performance snapshots
- Explicit logging for edge-case branches (to match tests)
"""

import logging
import json
from statistics import mean, pstdev
from typing import List, Optional, Dict, Any
from datetime import datetime

logger = logging.getLogger("hybrid_ai_trading.performance_tracker")
logger.setLevel(logging.DEBUG)


class PerformanceTracker:
    def __init__(self, window: int = 250):
        self.window = window
        self.trades: List[float] = []
        self.equity_curve: List[float] = []
        self.timestamps: List[datetime] = []

        # For drawdown tracking
        self.max_equity = 0.0
        self.max_drawdown = 0.0
        self.drawdown_start: Optional[datetime] = None
        self.drawdown_recovery: Optional[datetime] = None

        # Optional benchmark series (e.g., SPY returns)
        self.benchmark: List[float] = []

    # ----------------------------------------------------
    # Recorders
    # ----------------------------------------------------
    def record_trade(self, pnl: float):
        self.trades.append(pnl)
        if len(self.trades) > self.window:
            self.trades.pop(0)
        logger.debug(f"Recorded trade: {pnl}")

    def record_equity(self, equity: float, timestamp: Optional[datetime] = None):
        self.equity_curve.append(equity)
        self.timestamps.append(timestamp or datetime.utcnow())
        if len(self.equity_curve) > self.window:
            self.equity_curve.pop(0)
            self.timestamps.pop(0)

        # Track drawdown
        if equity > self.max_equity:
            self.max_equity = equity
            self.drawdown_start = self.timestamps[-1]
        drawdown = self.get_drawdown()
        if drawdown > self.max_drawdown:
            self.max_drawdown = drawdown
        if equity == self.max_equity:
            self.drawdown_recovery = self.timestamps[-1]

        logger.debug(f"Recorded equity: {equity}")

    def record_benchmark(self, ret: float):
        """Record benchmark return (e.g., SPY daily)."""
        self.benchmark.append(ret)
        if len(self.benchmark) > self.window:
            self.benchmark.pop(0)

    # ----------------------------------------------------
    # Ratios
    # ----------------------------------------------------
    def win_rate(self) -> float:
        if not self.trades:
            logger.info("No trades to compute win_rate")
            return 0.0
        return sum(1 for t in self.trades if t > 0) / len(self.trades)

    def payoff_ratio(self) -> float:
        if not self.trades:
            logger.info("No trades for payoff_ratio")
            return 0.0
        gains = [t for t in self.trades if t > 0]
        losses = [abs(t) for t in self.trades if t < 0]
        if not losses:
            logger.info("No losses available for payoff_ratio")
            return 0.0
        return (mean(gains) if gains else 0.0) / mean(losses)

    def roi(self) -> float:
        if not self.equity_curve or self.equity_curve[0] == 0:
            return 0.0
        return (self.equity_curve[-1] - self.equity_curve[0]) / self.equity_curve[0]

    def sharpe_ratio(self, risk_free: float = 0.0, annualize: bool = True) -> float:
        if len(self.trades) < 2:
            logger.info("Not enough trades for Sharpe ratio")
            return 0.0
        try:
            avg, std = mean(self.trades), pstdev(self.trades)
            if std == 0:
                return 0.0
            sr = (avg - risk_free) / std
            return sr * (252**0.5) if annualize else sr
        except Exception as e:
            logger.error(f"Sharpe calc error: {e}")
            return 0.0

    def sortino_ratio(self, risk_free: float = 0.0, annualize: bool = True) -> float:
        if len(self.trades) < 2:
            logger.info("Not enough trades for Sortino ratio")
            return 0.0
        avg = mean(self.trades)
        downside = [t for t in self.trades if t < 0]
        if not downside:
            logger.warning("No downside trades → fallback")
            return (avg - risk_free) / ((pstdev(self.trades) or 1.0))
        try:
            dd_std = pstdev(downside)
            if dd_std == 0:
                logger.warning("Downside stdev=0, using fallback")
                return (avg - risk_free) / 1.0
        except Exception as e:
            logger.error(f"Sortino calc error: {e}")
            return 0.0
        sr = (avg - risk_free) / dd_std
        return sr * (252**0.5) if annualize else sr

    def calmar_ratio(self) -> float:
        if self.max_drawdown == 0:
            return 0.0
        return self.roi() / self.max_drawdown

    def omega_ratio(self, threshold: float = 0.0) -> float:
        if not self.trades:
            return 0.0
        gains = [max(0, t - threshold) for t in self.trades]
        losses = [max(0, threshold - t) for t in self.trades]
        denom = sum(losses)
        return sum(gains) / denom if denom > 0 else 0.0

    # ----------------------------------------------------
    # Attribution vs Benchmark
    # ----------------------------------------------------
    def alpha_beta(self, risk_free: float = 0.0) -> Dict[str, float]:
        """CAPM-style regression vs benchmark."""
        if len(self.trades) < 2 or len(self.benchmark) < 2:
            return {"alpha": 0.0, "beta": 0.0}
        try:
            cov = mean(
                [
                    (r - mean(self.trades)) * (b - mean(self.benchmark))
                    for r, b in zip(self.trades, self.benchmark)
                ]
            )
            var_b = pstdev(self.benchmark) ** 2
            beta = cov / var_b if var_b > 0 else 0.0
            alpha = mean(self.trades) - (risk_free + beta * mean(self.benchmark))
            return {"alpha": alpha, "beta": beta}
        except Exception as e:
            logger.error(f"Alpha/Beta calc error: {e}")
            return {"alpha": 0.0, "beta": 0.0}

    # ----------------------------------------------------
    # Drawdown analytics
    # ----------------------------------------------------
    def get_equity_curve(self) -> List[float]:
        """Return a copy of the equity curve."""
        return list(self.equity_curve)

    def get_drawdown(self) -> float:
        if not self.equity_curve:
            logger.info("No equity data for drawdown")
            return 0.0
        peak = max(self.equity_curve)
        trough = self.equity_curve[-1]
        return (peak - trough) / peak if peak > 0 else 0.0

    def get_max_drawdown(self) -> float:
        return self.max_drawdown

    def drawdown_recovery_time(self) -> Optional[int]:
        """Return recovery time in days between drawdown start and recovery."""
        if self.drawdown_start and self.drawdown_recovery:
            return (self.drawdown_recovery - self.drawdown_start).days
        return None

    # ----------------------------------------------------
    # Export
    # ----------------------------------------------------
    def snapshot(self) -> Dict[str, Any]:
        """Return snapshot of current performance metrics."""
        return {
            "win_rate": round(self.win_rate(), 3),
            "payoff_ratio": round(self.payoff_ratio(), 3),
            "roi": round(self.roi(), 3),
            "sharpe": round(self.sharpe_ratio(), 3),
            "sortino": round(self.sortino_ratio(), 3),
            "calmar": round(self.calmar_ratio(), 3),
            "omega": round(self.omega_ratio(), 3),
            "alpha_beta": self.alpha_beta(),
            "drawdown": round(self.get_drawdown(), 3),
            "max_drawdown": round(self.get_max_drawdown(), 3),
            "dd_recovery_days": self.drawdown_recovery_time(),
        }

    def export_json(self, path: str):
        """Save snapshot to JSON file (audit-friendly)."""
        try:
            with open(path, "w") as f:
                json.dump(self.snapshot(), f, indent=2)
            logger.info(f"Performance snapshot exported → {path}")
        except Exception as e:
            logger.error(f"Failed to export performance snapshot: {e}")
