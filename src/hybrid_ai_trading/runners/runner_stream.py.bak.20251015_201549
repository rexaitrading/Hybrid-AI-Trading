import os, asyncio, pathlib, time, yaml
from datetime import datetime, timezone
from ib_insync import IB, Stock
from hybrid_ai_trading.utils.feature_store import FeatureStore
from hybrid_ai_trading.utils.exec import gc_stale_orders
from hybrid_ai_trading.utils.risk import intraday_risk_checks
from hybrid_ai_trading.utils.edges import decide_signal

UNIVERSE_FILE = "config/universe_equities.yaml"
POLL_SEC      = 0.50  # light housekeeping cadence

def load_universe():
    cfg = pathlib.Path(UNIVERSE_FILE)
    if not cfg.exists():
        raise FileNotFoundError(f"Universe file not found: {cfg}")
    with cfg.open("r", encoding="utf-8") as f:
        d = yaml.safe_load(f)
    syms = []
    for it in d.get("symbols", []):
        if isinstance(it, str):
            # allow "AAPL", "MSFT" or sloppy dash-separated lines; split safely
            parts = [p.strip() for p in it.replace(" - ", "\n").splitlines() if p.strip()]
            syms.extend(parts)
        elif isinstance(it, dict) and "file" in it:
            p = pathlib.Path(it["file"])
            if p.exists():
                syms += [s.strip() for s in p.read_text(encoding="utf-8").splitlines() if s.strip()]
    # de-dup while preserving order
    seen, out = set(), []
    for s in syms:
        if s not in seen:
            seen.add(s); out.append(s)
    return out

async def main():
    host = os.getenv("IB_HOST","127.0.0.1")
    port = int(os.getenv("IB_PORT","7497"))
    cid  = int(os.getenv("IB_CLIENT_ID","3021"))

    symbols = load_universe()
    print(f"[{datetime.utcnow().isoformat()}Z] boot | host={host}:{port} cid={cid} | syms={len(symbols)}", flush=True)

    ib = IB()
    await ib.connectAsync(host, port, clientId=cid, timeout=15)
    try:
        ib.reqMarketDataType(3)  # 1=real-time, 3=delayed
        print("[runner] marketDataType=DELAYED", flush=True)
    except Exception:
        pass

    # build/qualify contracts (async; no nested sync ._run calls)
    contracts = [Stock(sym, "SMART", "USD", primaryExchange="NASDAQ") for sym in symbols]
    # qualify sequentially to keep it simple & avoid throttling
    for c in contracts:
        await ib.qualifyContractsAsync(c)

    # request market data
    for c in contracts:
        # top-of-book; snapshot=False, regulatory snapshot=False
        ib.reqMktData(c, "", False, False)

    store = FeatureStore(root="data/feature_store")

    # tick handler: write quote, evaluate edge, place order if any
    def on_tick(ticker):
        c = ticker.contract
        if not c or not c.symbol:
            return
        bid, ask = ticker.bid, ticker.ask
        if bid is None or ask is None:
            return
        # Phase 4: write to store
        store.write_quote(
    symbol=c.symbol,
    ts=datetime.now(timezone.utc),
    bid=(t.bid or 0.0),
    ask=(t.ask or 0.0),
    last=(t.last or 0.0),
    bidSize=(t.bidSize or 0),
    askSize=(t.askSize or 0),
    lastSize=(t.lastSize or 0),
    spread=((t.ask - t.bid) if (t.ask is not None and t.bid is not None) else 0.0),
    imb=(((t.bidSize - t.askSize) / (t.bidSize + t.askSize))
        if (t.bidSize and t.askSize and (t.bidSize + t.askSize) != 0)
        else 0.0)
)else 0.0),
            imb=((t.bidSize - t.askSize)/(t.bidSize + t.askSize)) if (t.bidSize and t.askSize and (t.bidSize + t.askSize) != 0) else 0.0
        ),
            bid=bid, ask=ask, last=(ticker.last or 0.0),
            bidSize=(ticker.bidSize or 0), askSize=(ticker.askSize or 0), lastSize=(ticker.lastSize or 0),
            provider="IB", venue=c.primaryExchange or "SMART"
        )
        # Phase 5: edge + order
        sig = decide_signal(ticker)
        if sig.action and sig.order:
            try:
if can_trade():
        ib.placeOrder(c, sig.order)
            except Exception:
                # avoid raising in event callback
                pass

    # hook events
    for c in contracts:
        ib.ticker(c).updateEvent += on_tick

    # housekeeping (async-safe, no ib._run)
    try:
        while True:
            await asyncio.sleep(POLL_SEC)
            gc_stale_orders(ib, max_age_sec=60)
            intraday_risk_checks(ib)
    finally:
        ib.disconnect()

if __name__ == "__main__":
    asyncio.run(main())






